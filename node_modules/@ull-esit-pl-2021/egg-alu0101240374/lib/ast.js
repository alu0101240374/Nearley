class Value {
  constructor(token) {
    this.type = token.type;
    this.value = token.value;
  }
  evaluate(env) {
    return this.value;
  }
}

const XRegExp = require('xregexp');

class Regexp {
  constructor(token) {
    this.type = token.type;
    if (token.flags) {
      this.flags = token.flags;
    } else {
      this.flags = token.regex.substring(token.regex.lastIndexOf("/") + 1, token.regex.length);
    }
    if (token.regex[0] === 'r' && token.regex[1] === '/') {
      this.regex = token.regex.substring(2, token.regex.length - 2);
    } else {
      this.regex = token.regex;
    }
      // regex = regex.replace(/[\r\n]/g, '|');
    // regex = regex.replace(/\s/g, '');
    // while (regex[regex.length - 1] === '|') regex = regex.slice(0, -1);
  }
  evaluate(env) {
    const reg = (this.flags.length > 0) ? new XRegExp(this.regex, this.flags) : new XRegExp(this.regex);
    return reg;
  }
}

class Word {
  constructor(token) {
    this.type = token.type;
    this.name = token.name;
  }

  evaluate(env) {
    if (this.name in env) {
      return env[this.name];
    } else {
      throw new ReferenceError(`Undefined variable: ${this.name}`);
    }
  }
}

class Apply {
  constructor(tree) {
    this.type = tree.type;
    this.operator = tree.operator;
    this.args = tree.args;
  }

  evaluate(env) {
    const {specialForms} = require('./eggvm.js');
    if (this.operator.type == 'word' && this.operator.name in specialForms) {
      return specialForms[this.operator.name](this.args, env);
    }
    try {
      let op = this.operator.evaluate(env);
      let argsProcessed = this.args.map((arg) => arg.evaluate(env));
      if ((typeof op == 'function')) {
        return op(...argsProcessed);
      }
    } catch (err) {
      throw new TypeError('Applying not a function or method ' + err);
    }
  }
}

class MethodApply {
  constructor(tree) {
    this.type = tree.type;
    this.operator = tree.operator;
    this.args = tree.args;
  }

  evaluate(env) {
    // const {specialForms} = require('./eggvm.js');
    // if (this.operator.type == 'word' && this.operator.name in specialForms) {
    //   return specialForms[this.operator.name](this.args, env);
    // }
    try {
      let op = this.operator.evaluate(env);
      let argsProcessed = this.args.map((arg) => arg.evaluate(env)); //Probar: hacer map si no haces currying es inutil CREO
      let method = argsProcessed.shift();
      let methodName = method.toString();
      if ((typeof op[methodName] !== 'function')) {
        if (typeof op == 'string' || typeof op == 'number') return op[methodName];
        if (methodName in op) return op[methodName];
        if (op instanceof Map) {
          return op.get('"' + methodName + '"');
        }
        return op['"' + methodName + '"'];
      }
      return (...args) => op[methodName](...args);
    } catch (err) {
      throw new TypeError('Applying not a function or method ' + err);
    }
  }
}

let j2a = Object.create(null);

j2a['value'] = (node) => new Value(node);
j2a['word'] = (node) => new Word(node);
j2a['regex'] = (node) => new Regexp(node);
j2a['apply'] = (node) => {
  let apply = new Apply({
    type: "apply",
    args: [],
    operator: json2Ast(node.operator)
  });
  node.args.forEach(element => {
    apply.args.push(json2Ast(element));
  });
  return apply;
}

j2a['methodApply'] = (node) => {
  let apply = new MethodApply({
    type: "methodApply",
    args: [],
    operator: json2Ast(node.operator)
  });
  node.args.forEach(element => {
    apply.args.push(json2Ast(element));
  });
  return apply;
}

function json2Ast(node) {
  if (node && node.type && j2a[node.type])
    return j2a[node.type](node);
  else
    throw 'Not valid AST tree';
}

module.exports = {Value, Word, Apply, MethodApply, Regexp, json2Ast, j2a};