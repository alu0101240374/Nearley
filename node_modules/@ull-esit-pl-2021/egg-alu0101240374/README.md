Egg
  =========

  A small library providing utility methods for running programs in egg language

  ## Installation
  
  npm install @ull-esit-pl-2021/egg-alu0101240374 --save

  Globally:

  npm install -g @ull-esit-pl-2021/egg-alu0101240374

  ## Usage

  If you install this module locally in your directory, you should place yourself in it in order tu execute these commands.

  Executes _one.egg_ program
  ```
  $ npx egg example/one.egg
  ```
  Executes repl program
  ```
  $ npx egg
  ```
  Compile program
  ```
  $ npx eggc example/one.egg
  ```
  Execute compiled program
  ```
  $ npx evm example/two.egg.evm
  ```
  For any additional help write --help after any executable for example:    
  ```
  $ npx egg --help
  ```
  
  ### Input

  You should write a program with a syntax valid for egg language. for example: 

  ```
  do(
    define(x, 4),
      define(setx, fun(val, 
          set(x, val)
        )
    ),
  setx(50),
  print(x)
  )
  ```

  ### Output
  ```
  50
  ```

  ## New methodApply feature

  Now you can acces js methods with a new syntax. This syntax has the following form:

  ```
  print("hello"["length"])
  ```

  This program will print the length of the "hello" string.

  ## Extended Egg

  In this section, we are going to learn how to use the extended egg features:

  ### Negative index

  *About:* negative index will allow you to access the last element of an array.

  *Example:* 
  ```
    do{
      def(x, array(1, array(2,3))),
      print(element(x, -1)),        # [ 2, 3 ]
    }
  ```

  ### More tha one index

  *About*: When working with more than one dimensional arrays, you can access with multiple indexes. 

  *Example:*
  ```
  do(
    def(x, array(1, array(2,3))),
    print(element(x,0)),          # 1
    print(element(x,1)),          #  [ 2, 3 ]
    print(element(x,1,1)),        # 3
    print(element(x,-1,-1)),      # 3
    print(element(x,-1,0))        # 2
  )
  ```

  ### Modify an array

  *About*: Modify arrays is operative in egg. Also, this feature allows you to modify an element from a multi-dimensional array.

  *Example:*
  ```
  do(
    def(x, array(1,2,3, array(9,8,7))),
    set(x, 2, 9),
    print(x),             # [ 1, 2, 9, [ 9, 8, 7 ] ]
    set(x, 3, 1, 1000),
    print(x)              # [ 1, 2, 9, [ 9, 1000, 7 ] ]
    )
  ```

  ### Maps and Hashes

  *About*: Now egg has Maps. The work as other languages like javaScript.

  *Example:*
  ```
  do {
    def(x, map{"x", 4, "y", map{"z", 3}}),
    print(x),                               # { x: 4, y: { z: 3 } }
    print(element(x, "x")),                 # 4
    print(element(x, "y")),                 # { z: 3 }
    print(element(x, "y", "z")),            # 3
    set(x, "y", "z", 50),
    print(element(x, "y"))                  # { z: 50 }
  }
  ```

  ### New lexical operator ':'

  *About*: When creating a map, writing the key followed by a comma and then the value, is not common in many languages, that is why egg has the operator ':'.

  *Example:*
  ```
  do {
    def(x, map{x: 4, y: map{z: 3}}),
    print(x),                               # { x: 4, y: { z: 3 } }
    print(element(x, "x")),                 # 4
    print(element(x, "y")),                 # { z: 3 }
    print(element(x, "y", "z")),            # 3
    set(x, "y", "z", 50),
    print(element(x, "y"))                  # { z: 50 }
  }
  ```

  ### Sub method for Maps

  *About*: the 'sub' method now works with Maps.

  *Example:*
  ```
  do(
    def(x, map{a: 1, b: 4, c: map{d: 5, e: 3}}),
    print(x["sub"]("a")),      # 1
    print(x["sub"]("c", "d")), # 5
    print(x["sub"]("c")["e"]), # 3
    print(x["sub"]("b"))       # 4
  ) 
  ```

  ### OOP in Egg

  *About*: Egg has added objects. They work sinmilar as javaScript.

  *Example:*
  ```
  do {
    def(x, object {
      "c", 0,
      "gc",  ->{element(self, "c")},
      "sc",  ->{value, =(self, "c", value)},
      "inc", ->{=(self, "c", +(element(self, "c"),1))}
    }),

    print(x["gc"]()), # 0
    x["sc"](4),
    print(x["gc"]()), # 4
    x["inc"](),
    print(x["gc"]()), # 5
    print(x["c"]),    # 5
  }
  ```

  ### Dot as lexical operator

  *About*: When trying to access a javaScript method, the older version required a '[method]' syntax, now egg has a new operator '.'.

  *Example:*
  ```
  do(
    def(x, array(1,4,5)),
    def(s, x.join("-")),                 # The same as x["join"]("-")
    print(s),                            # 1-4-5
    print(array(1,4,5).join("-").length) # 5 Same as array(1,4,5)["join"]("-")["length"]
  )
  ```

  ### Require

  *About*: from now on, egg supports libraries. They must be added using require followed by the path of the library.

  *Example:*
  _Library_
  ```
  # module. Exports z
  do {
    print("inside module"),
    :=(z, map{inc: ->{x, 
                       +(x,1)
                     } # end fun
             } # end map
    ), # end of :=
    z  # last value is exported
  }
  ```

  Client_
  ```
  # module. Exports z
  do {
    :=(z, require("examples/require/module.egg")),
    print(z.inc(4)),
    :=(w, require("examples/require/module.egg")),
  }
  ```

  ### Regular Expresssions

  *About*: in order to create a regular expression, write 'r/' followed by the regex, and end with another '/'.

  *Example:*
  ```
  do {
    :=(r, r/(\w+)
           \s+
           (\d+)  # numero 
          /x),
    :=(s, r.test("a 4")),
    :=(m, r.exec(";;; a 42")),
    print(s),
    print(m),
  }
  ```

  ### For loop

  *About*: apart from the while loop, egg has now the for loop.

  *Example:*
  ```
  do(
    for(define(x, 0), <(x, 5), ++(x),
      print(x)
    )
  )
  ```

  ### For each loop
 
  *About*: the last feature is the for each loop. It works the same as javaScript.

  *Example:*
  ```
  do {
    def(x, arr(1, 2, 3)),
    foreach(x, x, print(x)), # Different x from inner and outer scope

    def(y, map(a: 1, b: 2, c: 3)),
    foreach(key, y.keys(), print(key.toUpperCase()))
  }
  ```
  
  ## Contributing

  In lieu of a formal styleguide, take care to maintain the existing coding style.
  Add unit tests for any new or changed functionality. Lint and test your code.

   ### Tests

    npm run test

   ### Adding plugins

   With this version of Egg, you can add plugins and new features to the language. Just follow the next steps:  

   - Create a _registry.js_ file.
   - Import the components you want to modify from 'lib/public.js'. For example: 

   ```js
    let {topEnv} = require('lib/public.js');
   ```

  The next step is adding the features to your code. In this example we will add the require functionality that will allow us to execute an external code using require(argument) and providing a path as an argument:  

  ```js
    const requireResults = new Map();

    topEnv["require"] = (path) => {
      debugger;
        if (typeof path !== 'string') {
          throw new Error('invalid argument for require, expected a string');
        }
        if (requireResults.has(path)) {
          return requireResults.get(path);
        } 
        else {
          const result = egg.runFromFile(path.replace(/\"/g,''));
          requireResults.set(path, result);
          return result;
        }
    }
  ```

  The next step is to export all the components you have modified:

  ```js
    module.exports = {topEnv};
  ```
  
  Now your code won't work if you execute it normally. For making this work, you must add the _-p <fileName>_ option at the execution instruction:  

  ```
  node bin/egg.js examples/one.egg -p ../lib/registry.js
  ```

  ### Adding methods with monkey patching

  If you want to add some methods to the js objects, you can do it following this steps:

  * First, find the 'monkey-patch.js' file.
  * Add the code for your new method using this example:  

  ```js
    String.prototype["monke"] = function(...args) {
      try {
        return "This is monkey-patching";
      } catch (error) {
        throw new Error("Error en monke\n", error);
      }
    }
  ```
  Now every string object has a "monke" method that returns "This is monkey-patching"  

  ## Release history

  * 1.0.0 Initial release
  * 1.1.0 Sticky added and comments
  * 1.2.0 Offset added
  * 1.2.1 Relp fixed
  * 1.2.2 Doc fixed
  * 1.3.0 Brackets work as parenthesis
  * 1.4.0 Supports multiline comments
  * 1.5.0 New aliases supported
  * 1.6.0 Classes added
  * 1.6.1 EVM bug fixed(now you can use evm files)
  * 1.7.0 Acces js methods and monkey patching
  * 1.8.0 Egg extended